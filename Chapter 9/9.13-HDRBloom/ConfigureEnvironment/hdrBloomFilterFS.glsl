#version 410 core

uniform sampler2D hdr_image;

out vec4 color;

const float weights[] =
float[](0.0024499299678342, 0.0043538453346397, 0.0073599963704157, 0.0118349786570722, 0.0181026699707781,
        0.0263392293891488, 0.0364543006660986, 0.0479932050577658, 0.0601029809166942, 0.0715974486241365,
        0.0811305381519717, 0.0874493212267511, 0.0896631113333857, 0.0874493212267511, 0.0811305381519717,
        0.0715974486241365, 0.0601029809166942, 0.0479932050577658, 0.0364543006660986, 0.0263392293891488,
        0.0181026699707781, 0.0118349786570722, 0.0073599963704157, 0.0043538453346397, 0.0024499299678342);

void main() {
    vec4 c = vec4(0.0);
    // 取到最左侧的第一个点，weights.length() >> 1 = weights.length的1/2
    ivec2 P = ivec2(gl_FragCoord.yx) - ivec2(0, weights.length() >> 1);
    
    // 1. 这里需要计算一行25个像素的加权平均值
    // 2. 这里纹素菜样应该是传入xy的值，但是其实传入的是yx的值，因此相当于反转。因此该GLProgram需要运行两次保证纹理被
    //    翻转回正确位置，也符合空间的卷积思想。
    for (int i = 0; i < weights.length(); i++) {
        c += texelFetch(hdr_image, P + ivec2(0, i), 0) * weights[i];
    }
    
    color = c;
}
